// Copyright gotools (https://github.com/zerjioang/gotools)
// SPDX-License-Identifier: GNU GPL v3

package randomuuid

import (
	"crypto/rand"
	"encoding/hex"
	"io"
	mrand "math/rand"

	"github.com/zerjioang/gotools/lib/fastime"
	"github.com/zerjioang/gotools/lib/snowflake"

	"github.com/zerjioang/gotools/lib/logger"
)

// RawUuidSize of a UUID in bytes.
const RawUuidSize = 16
const HexUuidSize = RawUuidSize * 2

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
func GenerateUUIDFromEntropy() string {
	var uuidData [RawUuidSize]byte
	_, err := io.ReadAtLeast(rand.Reader, uuidData[:], RawUuidSize)
	if err != nil {
		logger.Error("error generating UUID. caused by: ", err)
		return ""
	}

	// variant bits; see section 4.1.1
	uuidData[8] = uuidData[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuidData[6] = uuidData[6]&^0xf0 | 0x40

	var buf [36]byte

	hex.Encode(buf[0:8], uuidData[0:4])
	buf[8] = '-'
	hex.Encode(buf[9:13], uuidData[4:6])
	buf[13] = '-'
	hex.Encode(buf[14:18], uuidData[6:8])
	buf[18] = '-'
	hex.Encode(buf[19:23], uuidData[8:10])
	buf[23] = '-'
	hex.Encode(buf[24:], uuidData[10:])

	return string(buf[:])
}

func GenerateSnowFlakeId() [8]byte {
	n, _ := snowflake.NewNode(1)
	id := n.Generate()
	return id.IntBytes()
}

// GenerateIDString returns a UUID based on RFC 4122 returning the generated bytes
func GenerateIDString() UniqueIdHex {
	var buf UniqueIdHex
	var uuidData [RawUuidSize]byte
	var n int
	var nn int
	var err error
	for n < RawUuidSize {
		nn, err = rand.Read(uuidData[n:])
		n += nn
		nn = 0
	}
	if err != nil {
		logger.Error("error generating UUID. caused by: ", err)
		return buf
	}

	// variant bits; see section 4.1.1
	uuidData[8] = uuidData[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuidData[6] = uuidData[6]&^0xf0 | 0x40

	_ = hex.Encode(buf[:], uuidData[:])
	return buf
}

// GenerateIDRaw returns a UUID based on RFC 4122 returning the generated bytes
func GenerateIDRaw() UniqueIdRaw {
	var uuidData UniqueIdRaw
	var n int
	var nn int
	var err error
	for n < RawUuidSize {
		nn, err = rand.Read(uuidData[n:])
		n += nn
		nn = 0
	}
	if err != nil {
		logger.Error("error generating UUID. caused by: ", err)
		return uuidData
	}

	// variant bits; see section 4.1.1
	uuidData[8] = uuidData[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuidData[6] = uuidData[6]&^0xf0 | 0x40

	return uuidData
}

func ReadAtLeast(r io.Reader, buf [RawUuidSize]byte, min int) (n int, err error) {
	for n < min && err == nil {
		var nn int
		nn, err = r.Read(buf[n:])
		n += nn
	}
	return
}

const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

var (
	seededRand = mrand.New(mrand.NewSource(fastime.Unix()))
)

//BenchmarkGenerateUUID/random-str-charset-4        	 2000000	       888 ns/op	   1.13 MB/s	      64 B/op	       2 allocs/op
func StringWithCharset(length int, charset string) []byte {
	clen := len(charset)
	b := make([]byte, length)
	// bound check hack
	_ = charset[clen-1]
	_ = b[length-1]

	for i := 0; i < length; i++ {
		b[i] = charset[seededRand.Intn(clen)]
	}
	return b
}

func RandomStr(length int) []byte {
	return StringWithCharset(length, charset)
}
